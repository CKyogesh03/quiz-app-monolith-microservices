package com.yogesh.controller;

import com.yogesh.entity.Question;
import com.yogesh.entity.QuestionWrapper;
import com.yogesh.entity.Response;
import com.yogesh.repository.QuestionRepository;
import com.yogesh.service.QuestionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;

@RestController
@RequestMapping("/question")
public class QuestionController {
    private final QuestionService questionService;


    //pending - creating another instance of question service using intellij options
    //quiz service --> question service. if huge request comes from quiz service. then we need to balance the load. so another instance of question service is created to serve the work for quiz service.
    //when loadbalancing. find which instance is executed if multiple question service instance is created(horizontal scaling)
    @Autowired
    Environment environment;  // using this to find which instance is executing // if multiple instance is created to handle huge request


    public QuestionController(QuestionService questionService) {
        this.questionService = questionService;
    }

    @GetMapping("/allQuestions")
    public ResponseEntity<List<Question>> getAllQuestions(){
        try {
            return new ResponseEntity<>(questionService.getAllQuestions(),HttpStatus.OK);
        }
        catch (Exception e){
            e.printStackTrace();
        }
        return new ResponseEntity<>(new ArrayList<>(),HttpStatus.BAD_REQUEST);

    }

    @GetMapping("category/{category}")
    public ResponseEntity<List<Question>> getQuestionsByCategory(@PathVariable String category){
        try {
            return new ResponseEntity<>(questionService.getQuestionsByCategory(category), HttpStatus.OK);
        }
        catch (Exception e){
            e.printStackTrace();
        }
        return new ResponseEntity<>(new ArrayList<>(),HttpStatus.BAD_REQUEST);

    }

    @PostMapping("add")
    public ResponseEntity<Question> addQuestion(@RequestBody Question question){
        try {
            return new ResponseEntity<>(questionService.addQuestion(question),HttpStatus.CREATED);
        }
        catch (Exception e){
            e.printStackTrace();
        }
        return new ResponseEntity<>(new Question(),HttpStatus.BAD_REQUEST);
    }

    //generate //give only question id's // then these group of id's are mapped with single quiz id.
    @GetMapping("generate")
    public ResponseEntity<List<Integer>> getQuestionsForQuiz
    (@RequestParam String categoryName,@RequestParam Integer noOfQuestions){
        return questionService.getQuestionsForQuiz(categoryName,noOfQuestions);
    }

    //getQuestions based on the given question Id's // the id's are previously generated by previous method
    //QuestionWrapper returned bcoz no need to send the answers with question for quiz
    //when load balancing the request - request is randomly given to instance. if 2 instance is present then request is given to any of one randomly.// it checks which instance is free
    @PostMapping("getQuestions")
    public ResponseEntity<List<QuestionWrapper>> getQuestionsFromId(@RequestBody List<Integer> questionIds){
        System.out.println(environment.getProperty("local.server.port"));
        return questionService.getQuestionsFromIds(questionIds);
    }

    //getScore
    //using quiz result we can calculate the score of the result
    @PostMapping("getScore")
    public ResponseEntity<Integer> getScore(@RequestBody List<Response> responses){
        return questionService.getScore(responses);
        }
}